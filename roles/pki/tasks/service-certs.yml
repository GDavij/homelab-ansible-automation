- name: Verify if Certificate already exists for {{ service.name }}
  ansible.builtin.stat:
    path: "{{ pki_output_folder }}/{{ service.name }}.crt"
  register: pki_cert_exists
  delegate_to: localhost
  become: false
  tags:
    - pki
    - service-cert

- name: Verify Root CA are uploaded
  ansible.builtin.stat:
    path: "{{ pki_output_folder }}/authorities/root-ca.crt"
  register: pki_root_ca_stat
  delegate_to: localhost
  become: false
  tags:
    - pki
    - service-cert

- name: Verify Certificate is uploaded for {{ service.name }}
  ansible.builtin.stat:
    path: "{{ pki_output_folder }}/{{ service.name }}.crt"
  register: pki_service_cert_stat
  delegate_to: localhost
  become: false
  when: pki_cert_exists.stat.exists
  tags:
    - pki
    - service-cert

- name: Generate Certificate for {{ service.name }}
  when: >
    not pki_cert_exists.stat.exists or
    (pki_cert_exists.stat.exists and
     pki_service_cert_stat.stat.mtime < pki_root_ca_stat.stat.mtime)
  become: false
  block:
    - name: Generate Private Key for {{ service.name }}
      community.crypto.openssl_privatekey:
        path: "{{ pki_output_folder }}/{{ service.name }}.key"
        type: RSA
        size: 4096
        format: pkcs8
        state: present
      delegate_to: localhost
      tags:
        - pki
        - service-certs

    - name: Generate CSR for {{ service.name }}
      community.crypto.openssl_csr:
        path: "{{ pki_output_folder }}/{{ service.name }}.csr"
        privatekey_path: "{{ pki_output_folder }}/{{ service.name }}.key"

        # Certificate Metadata
        common_name: "{{ service.dns }}"
        organization_name: "{{ pki_ca_organization }}"
        organizational_unit_name: "{{ pki_ca_organizational_unit }}"
        country_name: "{{ pki_ca_country }}"
        state_or_province_name: "{{ pki_ca_state }}"
        locality_name: "{{ pki_ca_locality }}"

        # Subject Alt Name(SANs) - Include both DNS and IP for GhostTunnel compatibility
        subject_alt_name: "DNS:{{ service.dns }},IP:{{ service.ip }}"

        # Critical extensions for browser trust
        key_usage:
          - digitalSignature
          - keyEncipherment
        key_usage_critical: true
        extended_key_usage: "{{ ['serverAuth', 'clientAuth'] if service.credential_certificate | default(false) else ['serverAuth'] }}"
        extended_key_usage_critical: true
      delegate_to: localhost

    - name: Sign Certificate for {{ service.name }}
      community.crypto.x509_certificate:
        path: "{{ pki_output_folder }}/{{ service.name }}.crt"
        csr_path: "{{ pki_output_folder }}/{{ service.name }}.csr"

        # Using Root CA
        provider: ownca
        ownca_path: "{{ pki_output_folder }}/authorities/root-ca.crt"
        ownca_privatekey_path: "{{ pki_output_folder }}/authorities/root-ca.key"

        # Expiriration within 1 Year for Security
        ownca_not_after: "+365d"
        ownca_not_before: "-1d"
      delegate_to: localhost
